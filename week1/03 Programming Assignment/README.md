# set::iterator++ #
На лекциях вам было рассказано о внутреннем устройстве контейнеров map и set. Обычно map и set реализованы как двоичные деревья поиска.

Также вы узнали о том, как производится обход дерева с помощью итераторов.

В данной задаче мы будем работать не с контейнером set, но с аналогичным двоичным деревом поиска, состоящим из следующих вершин:

```objectivec
struct Node {
  int value;
  Node* left;
  Node* right;
  Node* parent;
};
```
Где:

 - value - значение, хранящееся в вершине;

 - left и right - указатели на дочерние вершины (оба равны nullptr для листьев дерева);

 - parent - указатель на родительскую вершину (равен nullptr для корня дерева).

Допустим, что для обхода дерева мы используем не специальный итератор, а просто указатель на вершину Node*.

Вам требуется реализовать функцию

```objectivec
Node* Next(Node* node);
```
, возвращающую указатель на следующую по возрастанию значения вершину.

Функция должна вернуть nullptr в случае, если текущая вершина -- последняя в дереве.
