## Виртуальный деструктор ##
 В формулировках предстоящих задач вы столкнётесь с таким явлением как "виртуальные деструкторы". В данном материале мы его обсудим. Вы уже знаете про деструкторы и про виртуальные функции по отдельности, но когда они объединяются вместе, появляется некоторая специфика.  

### Когда нужны виртуальные деструкторы ###
Виртуальные деструкторы могут понадобиться, когда у нас есть иерархия классов и динамические объекты. Рассмотрим простой пример:
```objectivec
class Shape {
public:
    virtual double Area() const = 0;
};

class Polygon : public Shape {
public:
    double Area() const override;
private:
    vector<Point> vertices_;
};
```
И рассмотрим такой пример кода:  
```objectivec
{
    unique_ptr<Shape> shape = make_unique<Polygon>();
}
```
Обратите внимание, что функция make_unique создаёт новый объект класса Polygon и возвращает unique_ptr<Polygon>, но при этом он сохраняется в умный указатель на базовый класс unique_ptr<Shape>. Это стандартная практика. Точно так же, как указателю на базовый класс можно присвоить указатель на класс наследник, умному указателю на базовый класс можно присвоить умный указатель на класс наследник. Это и позволяет нам использовать полиморфизм, в том числе с умными указателям.

Давайте подумаем, что произойдёт при разрушении объекта shape. Мы уже знаем, что деструктор unique_ptr<Shape>вызовет delete для динамического объекта. Но вопрос в том, какой будет тип указателя, переданного в delete. На самом деле, код выше эквивалентен вот такому:
```objectivec
  {
    Shape* shape = new Polygon;
    delete shape;
}
```
Теперь становится понятно, что delete вызывается для указателя на базовый класс Shape. Значит, delete вызовет деструктор класса Shape, что логично. Но ведь нам-то нужно, чтобы вызвался деструктор класса Polygon! Иначе некому будет удалить вектор вершин, и случится как минимум утечка памяти (на самом деле даже хуже - будет неопределённое поведение).

То есть получается, что мы удаляем динамический объект, используя указатель на базовый класс, и хотим, чтобы при этом вызывался деструктор класса наследника. Но ведь ровно такое поведение и позволяют делать виртуальные функции! Мы вызываем их через указатель (или ссылку) на базовый класс, а они исполняются в классе наследнике. В нашем же случае в качестве этой функции выступает деструктор. Именно его нам и нужно сделать виртуальным:
```objectivec
  class Shape {
public:
    virtual ~Shape() = default;  // Виртуальный деструктор

    virtual double Area() const = 0;
};
```
Теперь при вызове delete shape корректным образом вызовется деструктор класса Polygon. Выражение = default означает, что нас устраивает реализация деструктора по умолчанию, мы не хотим её менять, мы просто хотим сказать компилятору, что деструктор должен быть виртуальным.

### Свойства виртуальных деструкторов ###
Обратите внимание, что обычные виртуальные функции не вызывают свои реализации из базовых классов. Если нам это нужно, мы вызываем их в явном виде. Но с деструктором ситуация иная. Не важно, виртуальный он или нет, когда деструктор заканчивает свою работу, всегда вызываются деструкторы всех полей класса (в порядке обратном их объявлению), а потом деструкторы базовых классов (в порядке обратном их созданию).

Но, как и в случае обычных виртуальных функций, если в каком-то из базовых классов деструктор был объявлен виртуальным, то он останется виртуальным в текущем классе и во всех классах наследниках.

### Когда делать деструктор виртуальным ###
Из описания выше понятно, что виртуальный деструктор необходим, когда мы удаляем объект через указатель на базовый класс. Однако, в момент написания базового класса мы, вообще говоря, не знаем, собирается ли кто-то удалять наследников этого класса через указатель на этот класс. Мы же класс только что написали, у него ещё и наследников-то нет. Как тогда понять, нужен ли нам виртуальный деструктор?..

В качестве простого правила по умолчанию, деструктор следует объявлять виртуальным тогда и только тогда, когда ваш класс содержит виртуальные функции. При этом, если деструктор текущего класса уже является виртуальным в виду того, что он был объявлен виртуальным в одном из базовых классов, повторно его делать виртуальным, конечно, не нужно.

Существуют специфические ситуации, когда от этого правила можно отступать, но мы их с вами сейчас рассматривать не будем.
