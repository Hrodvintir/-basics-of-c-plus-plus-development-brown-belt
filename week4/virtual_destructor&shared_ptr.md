# Виртуальный деструктор и shared_ptr #
Ранее мы с вами познакомились с виртуальным деструктором, и посмотрели, когда он бывает необходим на примере обычных указателей и unique_ptr. Точно такая же логика применима и к shared_ptr. Но shared_ptr умеет кое-что ещё.

Если вы проходили курс "жёлтый пояс по С++", то вы можете помнить, как в блоке про полиморфизм мы создавали объекты производного класса Cat и сохраняли их в shared_ptr на базовый класс Animal:
```c++
shared_ptr<Animal> animal = make_shared<Cat>();
```
Причём мы не делали деструктор класса Animal виртуальным. Значит ли это, что у нас была утечка памяти?.. Вовсе нет.

Дело в том, что shared_ptr владеет особой магией, которая позволяет ему корректно удалять объект класса наследника по указателю на базовый класс даже без виртуального деструктора. Не вдаваясь в подробности, кратко рассмотрим, как это ему удаётся.

Для начала взглянем на документацию конструктора unique_ptr, который принимает сырой указатель:
```c++
explicit unique_ptr(pointer p) noexcept;
```
Здесь pointer - это тип сырого указателя, хранимого в unique_ptr, то есть мы рассматриваем класс unique_ptr<pointer>. Получается, что когда функция make_unique вызывает этот конструктор и передаёт в него указатель на класс наследник, этот указатель сразу же преобразуется в указатель на базовый класс. И информация о классе наследнике теряется. Поэтому нам для корректного удаления требуется виртуальный деструктор. Ведь связаться с классом наследником мы можем только через виртуальные функции.

Теперь посмотрим на документацию аналогичного конструктора shared_ptr:
```c++
template<class Y> 
explicit shared_ptr(Y* ptr);
```
  Мы видим, что он шаблонный. Тип указателя в параметре будет в точности соответствовать переданному в момент вызова. И за счёт этого информация о классе наследнике будет доступна компилятору в теле конструктора.

Конструктор, грубо говоря, обернёт выражение delete ptr в замыкание и сохранит его в контрольном блоке. И в момент, когда ему нужно будет удалить объект, он не будет вызывать delete для предоставляемого указателя на базовый класс, а вызовет сохранённое замыкание, которое знает, как удалять объект класса наследника.

Применительно к нашему примеру получается, что shared_ptr<Animal> на этапе выполнения сохранил в контрольном блоке знание, как работать с типом Cat, хотя не имеет к этому типу прямого отношения. Такая техника называется "type erasure".

Ок, это всё замечательно, но что это значит для вас? На самом деле, хм, не так уж много. Основная рекомендация остаётся точно такой же: деструктор следует объявлять виртуальным тогда и только тогда, когда ваш класс содержит виртуальные функции. Даже в том случае, если вы собираетесь работать с этим классом и его наследниками исключительно с помощью shared_ptr.

Цель этого материала в том, чтобы объяснить, почему код из жёлтого пояса работал корректно. И заодно показать хитрость и глубину shared_ptr. Обратите внимание, что подобная возможность никак не сказывается на быстродействии его работы! Он это делает просто потому, что может, и это ничего не стоит. В этом заключается философия С++: максимум гибкости, но без ущерба для производительности. В определённых специфических сценариях эта гибкость может понадобиться.
