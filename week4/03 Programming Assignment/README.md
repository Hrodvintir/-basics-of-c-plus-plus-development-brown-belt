Напишите свою упрощённую реализацию класса unique_ptr<T>. Подробную спецификацию стандартного unique_ptr можно посмотреть на cppreference. В этой задаче вам не нужно делать специализацию для массива и не нужно предусматривать свой Deleter. Назовите ваш класс UniquePtr. У класса должен быть один шаблонный параметр T — тип элемента, указатель на который будет храниться внутри.

Напишите следующие функции в классе:

 - Конструктор по умолчанию, создающий пустой умный указатель.

 - Конструктор, принимающий T* и захватывающий владение этой динамической памятью.

 - Конструктор перемещения, получающий на вход rvalue-ссылку на другой UniquePtr и отбирающий у него владение ресурсом.

 - Оператор присваивания, получающий на вход nullptr (тип - nullptr_t, определенный в заголовочном файле cstddef). В результате умный указатель должен стать пустым.

 - Move-оператор присваивания, получающий на вход rvalue-ссылку на другой UniquePtr.

 - Деструктор.

 - operator *, который возвращает T&.

 - Оператор -> (он должен вернуть указатель на обычную структуру, к которому можно применить обычный ->).

 - Функцию T* Release(), отменяющую владение объектом и возвращающую хранящийся внутри указатель.

 - Функцию void Reset(T* ptr), после выполнения которой умный указатель должен захватить ptr.

 - Функцию void Swap(UniquePtr& other), обменивающуюся содержимым с другим умным указателем.

 - Функцию T* Get() const, возвращающую указатель.

В вашем классе должны быть запрещены конструктор копирования и обычный оператор присваивания.

Использовать стандартный unique_ptr и заголовочный файл memory запрещается.
