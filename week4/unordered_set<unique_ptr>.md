# unordered_set<unique_ptr> #
Ранее мы с вами разбирали, как для решения задачи ObjectPool использовать контейнер set с элементами типа unique_ptr. Однако, выбор этого контейнера кажется не совсем верным, т.к. set - упорядоченный контейнер, а отношение порядка для указателей особого смысла не имеет. И мы уже знаем, что в подобных случаях эффективнее использовать неупорядоченные контейнеры.

В этом материале мы разберёмся, как использовать для этой задачи контейнер unordered_set.

Посмотрим, что нам нужно изменить относительно реализации, использующей контейнер set, которая была описана в начале блока. Для начала объявим поле allocated как unordered_set<unique_ptr<T>>. В методе Allocate() при этом не придётся делать никаких изменений.

А вот метод Deallocate() перестанет компилироваться. Давайте вспомним, как он выглядит:
```c++
template <typename T>
void ObjectPool<T>::Deallocate(T* object) {
  auto it = allocated.find(object);
  if (it == allocated.end()) {
    throw invalid_argument("");
  }
  free.push(move(allocated.extract(it).value()));
}
```

Проблема опять в том, что метод find() отказывается принимать сырой указатель. Давайте посмотрим документацию метода find() контейнера unordered_set:
  
```c++
iterator find(const Key& key);                            // (1)
const_iterator find(const Key& key) const;                // (2)
template<class K> iterator find(const K& x);              // (3) (since C++20)
template<class K> const_iterator find(const K& x) const;  // (4) (since C++20)
```
  
Функции точно такие же, как и для контейнера set. Аналогично, нам бы подошли перегрузки (3) и (4), выполняющие гетерогенный поиск. Однако, как мы видим, они доступны только начиная с С++20, и на момент написания материала (15 октября 2020) реализованы только в компиляторе MSVC (актуальный статус можно посмотреть в таблице C++ compiler support, строчка "Heterogeneous lookup for unordered containers"). Поэтому сначала рассмотрим решение, которое использует перегрузки (1) и (2).

В этом случае нам придётся создать некоторый unique_ptr, который мы будем искать. Создать его будет не сложно. У нас же есть конструктор, который принимает сырой указатель:
```c++
unique_ptr<T> ptr(object);
```
На лекции мы, правда, только что узнали, что использование такого конструктора противоречит соглашениям по владению динамическими объектами. Но в данном случае у нас нет выхода. Нам необходимо создать unique_ptr. Поэтому мы сознательно отступаем от соглашений.

Теперь мы можем вызвать метод find(), передав ему unique_ptr вместо сырого указателя:
  
```c++
  auto it = allocated.find(ptr);  // Раньше передавали object
```
  
И это будет работать. Указатель действительно будет искаться в нашем множестве. Но, как вы, вероятно, уже догадались, будет проблема. Наш ptr будет удалён при выходе из функции. И в своём деструкторе он, как честный unique_ptr, удалит объект, на который ссылается. А это явно не входило в наши планы.

Мы уже знаем, что unique_ptr удаляет объект, поскольку он владеет им. Нам же с вами нужно создать что-то вроде "невладеющего" unique_ptr. Прямо так в С++ сделать нельзя (к слову, для shared_ptr это сделать можно, и в последней лекции курса мы узнаем как). Но зато можно отозвать владение у unique_ptr. Для этого он предоставляет метод release(). Этот метод возвращает сырой указатель, которым владел unique_ptr, а сам unique_ptr при этом обнуляется. Объект же не удаляется, и владение им передаётся вызывающей стороне.

Используя метод release(), мы можем правильным образом сделать поиск объекта в исправленной версии Deallocate():
  
```c++
  unique_ptr<T> ptr(object);  // Создаём временный unique_ptr
auto it = allocated.find(ptr);  // Ищем его в множестве
ptr.release();  // Отзываем владение
```
Вот такой интересный финт, который иногда может быть полезен. Мы создали unique_ptr не потому, что нам нужно было управлять динамической памятью, а просто потому, что нам нужен был сам unique_ptr. Чтобы посчитать его хеш.

Обратите внимание, что метод release() по определению нарушает соглашения по владению динамическими объектами. В соответствии с соглашениями, unique_ptr владеет объектом. А тут раз, и он внезапно перестаёт владеть объектом. Но в данном случае мы использовали release(), т.к. уже определились, что нам приходится отступать от соглашений, ничего не поделаешь.

Теперь вспомним, что нам больше не нужны функции для сравнения unique_ptr с сырым указателем, и напишем полную реализацию класса ObjectPool с использованием контейнера unordered_set в стиле C++17 (без гетерогенного поиска) (комментарии указывают разницу с реализацией на set):
  
  ```c++
  template <class T>
class ObjectPool {
public:
  T* Allocate();
  T* TryAllocate();

  void Deallocate(T* object);

private:
  // Убрали свой компаратор

  queue<unique_ptr<T>> free;
  unordered_set<unique_ptr<T>> allocated;  // Изменили на unordered_set
};

template <typename T>
T* ObjectPool<T>::Allocate() {
  if (free.empty()) {
    free.push(make_unique<T>());
  }
  auto ptr = move(free.front());
  free.pop();
  T* ret = ptr.get();
  allocated.insert(move(ptr));
  return ret;
}

template <typename T>
T* ObjectPool<T>::TryAllocate() {
  if (free.empty()) {
    return nullptr;
  }
  return Allocate();
}

// Убрали функции сравнения, они больше не нужны

template <typename T>
void ObjectPool<T>::Deallocate(T* object) {
  // Добавили создание временного unique_ptr
  unique_ptr<T> ptr(object);
  auto it = allocated.find(ptr);
  ptr.release();
  if (it == allocated.end()) {
    throw invalid_argument("");
  }
  free.push(move(allocated.extract(it).value()));
}
  ```
  
  Заметим, что отступление от соглашений может быть чревато. Действительно, если во время работы метода find() возникнет исключение, то ptr.release() не будет вызван, и переданный объект будет удалён в деструкторе ptr. Что в дальнейшем приведёт к ошибке в результате двойного удаления, ведь у объекта где-то есть реальный владелец, который попытается его удалить. Ну и в целом, удалять объект, переданный по сырому указателю, который, как мы помним, является невладеющим - прямой и точный выстрел себе в ногу.

На практике, конечно, крайне маловероятно, что метод find() бросит исключение. Тем не менее, есть возможность сделать решение надёжным на 100% и предусмотреть даже такой экзотический случай. Для этого нам понадобится техника RAII, о которой мы расскажем в следующем блоке. Реализация конкретного решения этой проблемы с помощью техники RAII остаётся упражнением для самостоятельного выполнения.

Но более правильным решением, конечно, как и в случае с контейнером set, будет использование гетерогенного поиска. Так что, если ваш компилятор его поддерживает, то читаем дальше.
  
  ## Гетерогенный поиск ##
Забудем про изменения из предыдущей секции и снова посмотрим, что нам нужно изменить относительно реализации, использующей контейнер set. Нам понадобится только изменить тип контейнера allocated на unordered_set, причём таким образом, чтобы заработал гетерогенный поиск. Остальной код трогать вообще не будем.

Посмотрим, что пишет документация про перегрузки (3) и (4) метода find():

_3,4) [...] This overload only participates in overload resolution if `Hash::is_transparent` and `KeyEqual::is_transparent` are valid and each denotes a type. [...]_
 

Как видим, если для set нам было необходимо наличие типа Compare::is_transparent, то для unordered_set необходимо наличие типов Hash::is_transparent и KeyEqual::is_transparent.

Из документации контейнера unordered_set ясно, что типы Hash и KeyEqual передаются в шаблон и определяют, каким образом ключи хешируются и сравниваются. Что ж, давайте их определим и укажем в шаблоне:
  
  ```c++
  template <class T>
class ObjectPool {
  // ...

private:
  // Вместо компаратора определили хеширующий функтор и предикат сравнения
  struct Hash {
    using is_transparent = void;
    size_t operator()(const unique_ptr<T>& ptr) const {
      return hash<const T*>()(ptr.get());
    }
    size_t operator()(const T* ptr) const {
      return hash<const T*>()(ptr);
    }
  };
  struct KeyEqual {
    using is_transparent = void;
    bool operator()(const unique_ptr<T>& lhs, const unique_ptr<T>& rhs) const {
      return lhs == rhs;
    }
    bool operator()(const unique_ptr<T>& lhs, const T* rhs) const {
      return lhs.get() == rhs;
    }
    bool operator()(const T* lhs, const unique_ptr<T>& rhs) const {
      return lhs == rhs.get();
    }
  };

  queue<unique_ptr<T>> free;
  // Изменили на unordered_set с соответствующими параметрами
  unordered_set<unique_ptr<T>, Hash, KeyEqual> allocated;
};
  ```
  
  Для обоих типов Hash и KeyEqual мы определили вложенный тип is_transparent, чтобы включить нужные нам перегрузки функции find(). Тип Hash предоставляет operator() для unique_ptr и для обычного указателя.

Тип KeyEqual предоставляет operator() для сравнения unique_ptr и обычного указателя между собой, в разных комбинациях. Заметим, что комбинация сравнения обычного указателя с обычным нам здесь не нужна. Также обратите внимание, что когда мы писали компаратор для контейнера set, в нём мы сравнивали указатели с помощью функтора less. Это было необходимо, т.к. тогда нам был важен порядок указателей. А здесь нам важно только их равенство. Проверка на равенство это более простая операция, и, независимо от сложности устройства указателей, компилятор всегда может выполнить её оптимально. Поэтому стандартные операции сравнения "==" и "!=" для указателей ведут себя ожидаемым образом, и мы можем использовать их напрямую.

Это рабочая и наиболее простая для понимания реализация. Однако, удобнее её немного доработать, чтобы она стала короче и более универсальной.
  
 ## Шаблонизируем operator() ##
Сначала посмотрим на класс Hash. Воспользуемся тем фактом, что стандарт гарантирует, что хеши стандартных умных указателей unique_ptr и shared_ptr совпадают с хешами обычных указателей на тот же объект. Это значит, что нам нет смысла вызывать get() у unique_ptr. Можно вычислить его хеш напрямую:
  ```c++
    struct Hash {
    using is_transparent = void;
    size_t operator()(const unique_ptr<T>& ptr) const {
      // Используем специализацию hash для unique_ptr, а не для T*
      return hash<unique_ptr<T>>()(ptr);
    }
    size_t operator()(const T* ptr) const {
      return hash<const T*>()(ptr);
    }
  };
  ```
  
  Теперь видно, что оба operator() по сути одинаковы, но один использует T*, а другой - unique_ptr. Явный признак того, что можно заменить их оба на один шаблон:
  
  ```c++
  // operator() стал шаблонным и класс перестал быть вложенным в ObjectPool
struct Hash {
  using is_transparent = void;
  template <class P>
  size_t operator()(const P& p) const {
    return hash<P>()(p);
  }
};
  ```
  
  Поскольку теперь operator() стал шаблонным, нам больше нет необходимости знать о типе T, который передаётся в ObjectPool, и мы можем вынести класс Hash наружу (положить его непосредственно в какое-либо пространство имён). Это правильная вещь, и её следует сделать, т.к. когда он был помещён внутрь ObjectPool, для каждой специализации ObjectPool существовали свои независимые классы Hash. Это было оправдано в случе, когда их operator() не были шаблонными, но не имеет смысла после выполненного преобразования.

Теперь рассмотрим класс KeyEqual. Заметим, что и unique_ptr и обычный указатель у нас используются абсолютно одинаково, только для unique_ptr нам приходится вызывать метод get(). Если бы у нас была некоторая вспомогательная функция, которая принимает на вход произвольный указатель (не важно, умный или обычный) и возвращает обычный указатель, то мы могли бы вместо трёх operator() сделать один шаблонный.

И такая функция есть! Она называется to_address() и делает ровно то, что нам нужно. С её помощью мы можем заменить все перегрузки operator() одним шаблоном:
  
  ```c++
  // operator() стал шаблонным и класс перестал быть вложенным в ObjectPool
struct KeyEqual {
  using is_transparent = void;
  template <class P, class Q>
  bool operator()(const P& lhs, const Q& rhs) const {
    return to_address(lhs) == to_address(rhs);
  }
};
  ```
  
  Аналогично ситуации с классом Hash, мы вынесем класс KeyEqual наружу из ObjectPool.

Такая реализация стала короче и позволяет использовать указатель любого вида для поиска в контейнере. Например, shared_ptr, или даже какой-то свой особо умный указатель, для которого предоставлены подходящие специализации классов hash и pointer_traits (он используется функцией to_address()).

Теперь запишем окончательную реализацию класса ObjectPool с использованием контейнера unordered_set в стиле C++20 (с гетерогенным поиском) (комментарии указывают разницу с реализацией на set):
  
  ```c++
  // Добавили свои классы для хеширования и сравнения ключей
struct Hash {
  using is_transparent = void;
  template <class P>
  size_t operator()(const P& p) const {
    return hash<P>()(p);
  }
};
struct KeyEqual {
  using is_transparent = void;
  template <class P, class Q>
  bool operator()(const P& lhs, const Q& rhs) const {
    return to_address(lhs) == to_address(rhs);
  }
};

template <class T>
class ObjectPool {
public:
  T* Allocate();
  T* TryAllocate();

  void Deallocate(T* object);

private:
  // Убрали свой компаратор

  queue<unique_ptr<T>> free;
  // Изменили на unordered_set с соответствующими параметрами
  unordered_set<unique_ptr<T>, Hash, KeyEqual> allocated;
};

template <typename T>
T* ObjectPool<T>::Allocate() {
  if (free.empty()) {
    free.push(make_unique<T>());
  }
  auto ptr = move(free.front());
  free.pop();
  T* ret = ptr.get();
  allocated.insert(move(ptr)); 
  return ret;
}

template <typename T>
T* ObjectPool<T>::TryAllocate() {
  if (free.empty()) {
    return nullptr;
  }
  return Allocate();
}

// Убрали функции сравнения, они больше не нужны

template <typename T>
void ObjectPool<T>::Deallocate(T* object) {
  auto it = allocated.find(object);
  if (it == allocated.end()) {
    throw invalid_argument("");
  }
  free.push(move(allocated.extract(it).value()));
}
  ```
  
  Описанное решение будет работать в 100% случаев и является идиоматическим. Однако, оно потребовало написать достаточно много достаточно тупого кода, даже после шаблонизации operator() (такой код обычно называется "boilerplate"). К сожалению, в С++ такое частенько случается. Его философия в том, что вы можете максимально настроить его под свои нужды, и из коробки он предоставляет только самые необходимые для этого инструменты. Но порой это приводит к тому, что решение казалось бы простой и часто встречающейся задачи требует много не слишком выразительного кода.

Хорошие новости в том, что, во-первых, объём этого кода никак не сказывается на производительности скомпилированной программы, и такое решение должно работать быстрее, чем то, когда мы создавали временный unique_ptr. И, во-вторых, вся эта сложность спрятана в объявлении типа unordered_set, а код функции Deallocate() (как и всех остальных функций) у нас остался таким же простым, как был до этого.
  
