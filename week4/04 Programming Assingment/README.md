# RAII Booking
На лекции мы написали класс TripManager для бронирования набора перелётов и отелей, использующий вспомогательные классы FlightProvider и HotelProvider. Следуя идиоме RAII, мы вынесли забронированный набор в отдельный класс Trip. Код, написанный на лекции, мы немного модифицировали и поместили в файлы old_booking_providers.h и old_trip_manager.h

Вам теперь предлагается сделать так, чтобы отдельные бронирования перелёта и отеля тоже были оформлены в духе RAII. Это позволит упростить класс Trip: в его функции Cancel не придётся вызывать отмены бронирований, а достаточно будет просто удалить элементы из векторов.

Вам даны новые версии классов TripManager, Trip, FlightProvider и HotelProvider, которые лежат в файлах new_booking_providers.h и new_trip_manager.h. Функцию Cancel в новых классах мы переименовали в CancelOrComplete: она должна будет автоматически вызываться не только при отмене бронирования, но и при успешном его завершении. Теперь функции Book и CancelOrComplete в классах-провайдерах возвращают и принимают не BookingId, а специальный класс, который вам и нужно создать.

Так как FlightProvider и HotelProvider имеют одинаковый интерфейс, то, чтобы избежать дублирования кода, мы просим вас разработать шаблонный класс Booking<Provider>, где в качестве шаблонного типа будут выступать FlightProvider и HotelProvider.

Пришлите в тестирующую систему файл booking.h, который:
  
 - содержит пространство имён RAII

 - внутри пространства имён RAII содержит определение шаблонного класса Booking<Provider>
  
  Интерфейс класса Booking<Provider> должен стать вам понятен после изучения файлов new_booking_providers.h и new_trip_manager.h.

Для удобства тестирования мы сделали счётчик бронирований и максимально допустимое количество бронирований публичными статическими переменными классов FlightProvider и HotelProvier.
  
