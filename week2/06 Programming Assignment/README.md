# Двойная диспетчеризация
## Теория — статический и динамический тип указателя или ссылки на объект ##

Рассмотрим простой код

```objectivec
struct Parent {
  virtual string Name() const { return "Parent"; }
};

struct Child : Parent {
  virtual string Name() const override { return "Child"; }
};

void Print(const Parent& object) {
  cout << object.Name() << '\n';
}

int main() {
  Print(Parent());
  Print(Child());
}
```

Если у вас спросить, какой тип имеет параметр object функции Print, вы наверняка ответите «const Parent&» и будете правы. А если мы спросим, на объект какого типа ссылается параметр object, то правильным будет ответ: «Зависит от того, какой объект передали в функцию Print».

Получается, с одной стороны, мы знаем, какой тип имеет параметер object, но с другой стороны, мы не можем точно сказать, на объект какого типа он ссылается. В этом и состоит разница между статическим и динамическим типом ссылки (или указателя) на класс, у которого могут быть наследники.

Статический тип ссылки — это тип, известный на этапе компиляции. В нашем примере статический тип параметра object — это const Parent&.

Динамический тип ссылки — это тип объекта, на который она ссылается в данный момент времени. Динамическим типом параметра object во время первого вызова функции Print будет const Parent, во время второго вызова функции Print — const Child.

## Теория — тип указателя this в классах-наследниках ##

Теперь давайте рассмотрим другой пример. Как вы думаете, что будет выведено на экран?
```objectivec
struct Parent;
struct Child;

void PrintType(Parent*) { cout << "Parent\n"; }
void PrintType(Child*) { cout << "Child\n"; }

struct Parent {
  virtual void Print() { PrintType(this); }
};

struct Child : Parent {
};

int main() {
  Child().Print();
}
```

Вариантов, на самом деле, всего два, и правильный — это «Parent». Несмотря на то, что мы создали объект типа Child, указатель this внутри методов класса Parent имеет тип Parent*, а не Child*, как могло бы показаться. И это логично, потому что

 - выбор, какая из двух функций PrintType будет вызвана из метода Parent::Print, осуществляется на этапе компиляции; в этот момент компилятор наверняка знает только одно — что указатель this будет указывать на объект класса Parent

 - виртуальными (то есть зависящими от динамического типа) в C++ могут быть только методы, а this — это лишь указатель.

Наконец, рассмотрим ещё один пример и снова зададимся вопросом, что он выведет:
```objectivec
struct Parent;
struct Child;

void PrintType(Parent*) { cout << "Parent\n"; }
void PrintType(Child*) { cout << "Child\n"; }

struct Parent {
  virtual void Print() { PrintType(this); }
};

struct Child : Parent {
  void Print() override { PrintType(this); }
};

int main() {
  Child().Print();
}
```
Мы переопределили метод Print в классе Child, оставив у него точь-в-точь такую же реализацию, какая была в Parent::Print. Но кое-что изменилось — тип указателя this. Внутри метода Child::Print он имеет тип Child*. Причина та же — когда компилятор обрабатывает метод Child::Print, он знает, что this точно будет указывать на объект класса Child.

Итак, главный вывод — this всегда имеет тип указателя на тот класс, в методе которого он используется.

## Условие задачи ##
Из лекций мы узнали, что this всегда указывает на текущий объект класса, а также, что он является неявным параметром всех его методов. Кроме того, мы только что познакомились с понятиями статического и динамического типов ссылки (или указателя). В этой задаче мы объединим эти знания, чтобы реализовать так называемую двойную диспетчеризацию — мы напишем функцию, которая ведёт себя по-разному в зависимости от динамических типов двух объектов, которые в неё переданы.

Представим, что мы пишем движок для классической компьютерной стратегии: игроки строят города, формируют армию, а потом сражаются друг с другом. В нашей игре есть несколько объектов:

 - юниты — это солдаты, рабочие, кавалеристы и т.д.

 - здания — фабрики, заводы, казармы и т.д.

 - башни и стены — защитные сооружения для обороны своего города

Мы работаем над функциональностью размещения новых объектов на игровой карте. Допустим, мы хотим построить новое здание. Мы начинаем искать на карте место, где его можно разместить, а графический интерфейс игры нам в этом помогает. Здание можно построить в том месте карты, где нет других объектов. Если в текущей позиции здание пересекается с каким-то из объектов, то интерфейс рисует наше здание красным цветом, сообщая, что здесь его построить нельзя.

При этом юниты представляются точкой на плоскости, здания — прямоугольником, башни — кругом, а стены — отрезком. Кроме того, для каждого игрового объекта в нашем движке заведён отдельный класс, который наследуется от абстрактного класса GameObject:

```objectivec
class Unit;
class Building;
class Tower;
class Fence;

struct GameObject {
  virtual ~GameObject() = default;

  virtual bool Collide(const GameObject& that) const = 0;
  virtual bool CollideWith(const Unit& that) const = 0;
  virtual bool CollideWith(const Building& that) const = 0;
  virtual bool CollideWith(const Tower& that) const = 0;
  virtual bool CollideWith(const Fence& that) const = 0;
};
```
Наша задача — реализовать функцию bool Collide(const GameObject& first, const GameObject& second), которая проверяет пересекаются ли два игровых объекта, то есть имеют ли они хотя бы одну общую точку.

Вам даны:

 - файл game_object.h, содержащий интерфейс GameObject и объявление функции Collide

 - файлы geo2d.h/cpp, содержащие библиотеку для работы с геометрическими фигурами на плоскости; библиотека состоит из классов Point, Rectangle, Circle и Segment и набора функций Collide, которые умеют определять пересечение для каждой пары фигур (занимательный факт — все функции реализованы в целых числах, без применения вычислений в типе double)

 - файл collide.cpp, содержащий заготовку решения, а также юнит-тест, эмулирующий размещение нового объекта на игровой карте

Пришлите в тестирующую систему файл collide.cpp, который будет:

 - подключать game_object.h

 - содержать реализации классов Unit, Building, Tower и Fence (все они должны наследоваться от GameObject и реализовывать его интерфейс)

 - содержать реализацию функции bool Collide(const GameObject& first, const GameObject& second), которая возвращает true, если объекты first и second имеют на плоскости хотя бы одну общую точку, и false в противном случае.

### Замечание ###
Один из способов реализовать функцию Collide — использовать dynamic_cast. Мы не освещали его в лекциях. Кроме того, этот способ приводит к появлению развесистого кода, подверженного возникновению ошибок. Мы хотим, чтобы в этой задаче вы хорошенько разобрались с понятиями статического и динамического типа, а также поработали с указателем this. Поэтому мы будем компилировать ваши решения с флагом -fno-rtti, который будет приводить к ошибкам компиляции в случае использования dynamic_cast.

