# Функции с побочными эффектами
В этом материале мы обсудим функции, которые меняют некоторые свои параметры, принимая их по неконстантной ссылке (или неконстантному указателю). Начнём с примера.

### Пример: функция BookRooms
Пример будет основан на классе HotelManager из задачи «Система бронирования отелей», так что напомним его публичный интерфейс:
```c++
class HotelManager {
public:
  void Book(int64_t time, const string& hotel_name,
            int client_id, int room_count);
  
  int ComputeClientCount(const string& hotel_name);
  int ComputeRoomCount(const string& hotel_name);
  
private:
  // ...
};
```
Представим, что некоторый пользователь этого класса — например, туристическая компания — хочет автоматизировать один из своих наиболее частых сценариев работы с HotelManager — групповое бронирование номеров:  
```c++
for (int client_id = first_client_id;
     client_id < first_client_id + client_count;
     ++client_id) {
  manager.Book(time, hotel_name, client_id, room_count_per_client);
}
```
Этот код можно вынести в функцию, но тогда объект HotelManager нужно принять по неконстантной ссылке, чтобы менять его внутри функции:  
```c++
void BookRooms(
    HotelManager& manager, const string& hotel_name, int64_t time,
    int client_count, int first_client_id, int room_count_per_client
) {
  for (int client_id = first_client_id;
       client_id < first_client_id + client_count;
       ++client_id) {
    manager.Book(time, hotel_name, client_id, room_count_per_client);
  }
}
```
Вызов этой функции будет выглядеть следующим образом:  

```c++
BookRooms(manager, hotel_name, time, 10, 1672945, 2);
```
Этот подход порождает несколько проблем и вопросов.

Во-первых, в месте вызова функции ничто не предвещает изменения переменной manager: она находится в списке аргументов наравне с остальными. В данном случае ещё можно заподозрить неладное по отсутствию возвращаемого значения, но если функция начнёт что-нибудь возвращать, останется уповать лишь на название функции. Эту проблему мы рассмотрим в первую очередь.

Во-вторых, вызов функции теряет в понятности и безопасности из-за трёх чисел в списке аргументов. Рассмотрение этой проблемы мы начнём в видео про громоздкость конструкторов, а закончим — в материале про громоздкие сигнатуры функций.

Наконец, позволим высказаться внутреннему параноику. Основные проблемы при использовании интерфейсов (и, в частности, функций) возникают при расхождении декларируемой функциональности (что, как заявлено, функция делает) и технически допустимой (что функция может сделать, исходя из сигнатуры). Разберём этот дисбаланс на примере функции BookRooms:

 - **Что функция делает (обещает делать)?** Для объекта manager некоторое количество раз вызывает метод Book.

 - **Что функции позволено делать?** Как угодно менять объект manager. Например, она может создать новый HotelManager и заменить им существующий: manager = HotelManager();

Последнюю проблему мы рассмотрим в этом материале. Стоит, однако, заметить, что для небольших функций этот дисбаланс не доставляет больших хлопот, но при этом при попытке его устранить код существенно разбухает. Именно поэтому этот материал вынесен из видео в текст: помните о существовании подобных проблем, возьмите на вооружение способы их решения, но применяйте с умом, чётко представляя себе последствия для компактности кода.
### Как сделать вызов функции более прозрачным
**Способ 1. Принимать по указателю**
Довольно распространённый и часто рекомендуемый способ решить проблему понятности вызова — передавать изменяемые параметры по указателю:
```c++
void BookRooms(
    HotelManager* manager, const string& hotel_name, int64_t time,
    int client_count, int first_client_id, int room_count_per_client
);
```
Благодаря оператору получения адреса & изменяемые параметры становятся легко отличимыми при вызове функции:  
```c++
BookRooms(&manager, hotel_name, time, 10, 1672945, 2);
```
Недостатки:

 - Если аргумент manager принимается по указателю, нужно быть готовым к тому, что этот указатель может оказаться нулевым.

 - Такая договорённость фактически запрещает принимать параметры по константному указателю, как мы обсуждали ранее: & в месте вызова будет автоматически считываться как признак изменяемого аргумента.

 - Эта договорённость исключительно стилистическая: «О, давайте заменим ссылку на указатель — тогда при вызове появится амперсанд!» Компилятор никак не соотнесёт факт использования указателя с изменяемостью или неизменяемостью. (С другой стороны, в утилиты проверки стиля вполне можно добавить запрет на неконстантные ссылки в параметрах функций.)

**Способ 2. Принимать по значению и возвращать новое состояние**
В некоторых проектах используется другой способ решения проблемы изменяемых параметров: передавать их по значению и возвращать новое состояние:
```c++
HotelManager BookRooms(
    HotelManager manager, const string& hotel_name, int64_t time,
    int client_count, int first_client_id, int room_count_per_client
);
```
По сути предлагается переформулировать задачу функции из «принять разные входные данные, а ещё manager, который нужно обновить» в «принять разные входные данные, в том числе manager — и вернуть новое состояние manager». Таким образом, функция становится более предсказуемой за счёт уже известной концепции: принять входные данные и вернуть результат.

При вызове функции появляется не только явное выделение «изменяемого» параметра, но и выбор: нужно ли его изменять или отдать на растерзание копию.
```c++
// Изменяем manager, и это очевидно из этой строчки
manager = BookRooms(move(manager), hotel_name, time, 10, 1672945, 2);

// Функция не меняет переданные ей объекты и возвращает новый HotelManager
HotelManager new_manager = BookRooms(manager, hotel_name, time, 10, 1672945, 2);

```
Очевидный недостаток такого подхода — его неэффективность при работе с типами с большим количеством данных на стеке.

### Проблемы
Обозначим проблемы обоих способов:

 - Вседозволенность. Функция BookRooms в любом из рассмотренных вариантов может изменить manager совершенно произвольным образом. Действительно ли это необходимо?

 - Тестируемость. Раз с объектом manager может произойти всё, что угодно, в юнит-тестах изменённый объект необходимо проверять целиком, убеждаясь, что функция ничего не испортила.

Как упоминалось выше, часто эти проблемы не являются достаточным обоснованием для серьёзных изменений в коде, но осознавать их наличие всё же необходимо.

### Как избавиться от прямого взаимодействия с HotelManager
Для начала, рассмотрим простой случай — функцию, принимающую по неконстантной ссылке один объект и вызывающую у него один и тот же неконстантный метод. Такую функцию можно переписать так, чтобы её суть была непосредственно отражена в сигнатуре. Для этого выделим отдельный объект «запрос к методу Book» и вернём из функции набор таких объектов:
```c++
struct BookingQuery {
  int64_t time;
  const string& hotel_name;
  int client_id;
  int room_count;
};

vector<BookingQuery> BookRooms(
    const string& hotel_name, int64_t time,
    int client_count, int first_client_id, int room_count_per_client
) {
  vector<BookingQuery> queries;
  queries.reserve(client_count);
  for (int client_id = first_client_id;
       client_id < first_client_id + client_count;
       ++client_id) {
    queries.push_back({time, hotel_name, client_id, room_count_per_client});
  }
  
  return queries;
}
```
Чтобы применить набор запросов к объекту HotelManager, нужно:

 - Добавить в класс HotelManager метод void BookMany(const vector<BookingQuery>& queries) — если класс в вашей власти.

 - Написать функцию void BookMany(HotelManager& manager, const vector<BookingQuery>& queries): она всё так же принимает HotelManager по неконстантной ссылке, но максимально проста и вряд ли будет модифицироваться.

Цена такого рефакторинга — не только раздувание кода, но и накладные расходы на составление и хранение вектора запросов. С другой стороны, тестировать такую функцию одно удовольствие: по сути тесты явно проверят, какие запросы должны быть выполнены.

Если функция вызывает у изменяемого объекта не один метод, а несколько, возможны разные ситуации:

 - В одной части функции вызывается один метод, в другой части — другой. В этом случае стоит подумать о разделении функции на несколько.

 - Функция вызывает несколько методов в произвольном порядке. В этом случае можно прибегнуть к упомянутому выше рефакторингу, выделив несколько классов запросов с общим базовым классом, и возвращать вектор умных указателей на базовые запросы. (И код раздувается ещё сильнее.)

 - Функция не просто вызывает неконстантные методы, не интересуясь успешностью вызова, а существенно использует их возвращаемое значение и возможно, дополнительно вызывает константные методы. Такой функции нельзя обойтись без настоящего изменяемого объекта. Но, возможно, эта функция должна стать неконстантным методом этого объекта?
  
### Как переписать функцию, чтобы побочные эффекты наступали ровно для одного параметра
Более сложная ситуация — это функция, принимающая по неконстантной ссылке и изменяющая в процессе работы сразу несколько параметров. В этом случае можно рассмотреть варианты объединения этих нескольких объектов в один, а затем перейти к идеям из предыдущего раздела.

####Пример 1: бронирование и логирование
Представим, что функция должна не только забронировать номера, но и сообщить об этом в лог:
  ```c++
  void BookRooms(
    HotelManager& manager, Logger& logger,
    const string& hotel_name, int64_t time,
    int client_count, int first_client_id, int room_count_per_client
) {
  for (int client_id = first_client_id;
       client_id < first_client_id + client_count;
       ++client_id) {
    manager.Book(time, hotel_name, client_id, room_count_per_client);
    logger.LogBooking(time, client_id, room_count_per_client);
  }
}
  ```
Помимо непредсказуемости изменения объекта, переданного в функцию по неконстантной ссылке, в этой функции есть ещё одна проблема. Если предполагается, что manager.Book и logger.LogBooking всегда вызываются вместе, то это должно чем-то гарантироваться — иначе есть риск ошибиться и для одного из Book не вызвать LogBooking (если представить себе более запутанную функцию).

Решение — объединить HotelManager и Logger в один прокси-объект:
```c++
    class HotelManagerWithLogger {
public:
  HotelManagerWithLogger(HotelManager& manager, Logger& logger)
      : manager_(manager),
        logger_(logger)
  {}
  
  void Book(int64_t time, const string& hotel_name,
            int client_id, int room_count) {
    manager_.Book(time, hotel_name, client_id, room_count);
    logger_.LogBooking(time, client_id, room_count);
  }
  
private:
  HotelManager& manager_;
  Logger& logger_;
};

void BookRooms(
    HotelManagerWithLogger& manager,
    const string& hotel_name, int64_t time,
    int client_count, int first_client_id, int room_count_per_client
) {
  for (int client_id = first_client_id;
       client_id < first_client_id + client_count;
       ++client_id) {
    manager.Book(time, hotel_name, client_id, room_count_per_client);
  }
}                              
```
При вызове этой функции достаточно будет создать этот прокси-объект от переменных HotelManager и Logger:  
  ```c++
  HotelManager manager;
Logger logger;
// ...
HotelManagerWithLogger manager_with_logger(manager, logger);
BookRooms(manager_with_logger, hotel_name, time, 10, 1672945, 2);

  ```
Обратите внимание, что текущая версия функции BookRooms отличается от исходной лишь типом первого параметра. Это наводит на мысли о шаблонизации по типу HotelManager, что действительно будет иметь смысл, если в разных местах программы необходимо вызывать эту функцию как с логгером, так и без него.

Дальнейшее развитие рефакторинга предсказуемо: переделываем функцию на возврат vector<BookingQuery> в точности упомянутым выше способом и добавляем в HotelManagerWithLogger метод BookMany (или шаблонизируем функцию BookMany типом HotelManager, позволяя передать в неё HotelManagerWithLogger).

#### Пример 2: бронирование отелей и авиарейсов
Рассмотрим ещё один пример использования прокси-объектов для уменьшения количества изменяемых параметров функции: представим, что вместе с комнатами в отеле необходимо бронировать ещё и билеты на самолёт:
  
```c++
  void OrganizeTrip(
    HotelManager& hotel_manager, AirlineTicketManager& airline_manager,
    const string& hotel_name, int64_t time,
    int client_count, int first_client_id,
    int room_count_per_client, int ticket_count_per_client
) {
  for (int client_id = first_client_id;
       client_id < first_client_id + client_count;
       ++client_id) {
    hotel_manager.Book(time, hotel_name, client_id, room_count_per_client);
    airline_manager.Book(time, client_id, ticket_count_per_client);
  }
}
  ```
Уже известный вариант рефакторинга — завести прокси-объект TripManager, хранящий ссылки на HotelManager и AirlineTicketManager:  
```c++
   class TripManager {
public:
  TripManager(HotelManager& hotel_manager,
              AirlineTicketManager& airline_manager)
      : hotel_manager_(hotel_manager),
        airline_manager_(airline_manager)
  {}
  
  void Book(int64_t time, const string& hotel_name,
            int client_id, int room_count, int ticket_count) {
    hotel_manager_.Book(time, hotel_name, client_id, room_count);
    airline_manager_.Book(time, client_id, ticket_count);
  }
  
private:
  HotelManager& hotel_manager_;
  AirlineTicketManager& airline_manager_;
};

void OrganizeTrip(
    TripManager& manager,
    const string& hotel_name, int64_t time,
    int client_count, int first_client_id,
    int room_count_per_client, int ticket_count_per_client
) {
  for (int client_id = first_client_id;
       client_id < first_client_id + client_count;
       ++client_id) {
    manager.Book(time, hotel_name, client_id,
                 room_count_per_client, ticket_count_per_client);
  }
}                            
```
С другой стороны, уже намечаются предпосылки к двукратному раздуванию параметров функции OrganizeTrip и метода TripManager::Book: легко себе представить добавление названия авиакомпании и других параметров перелёта. Поэтому, если логика перебора client_id не слишком уникальна, стоит рассмотреть вариант с разделением функции на две: одна для отелей, вторая для авиабилетов.

## Итоги
 - Изменяемые параметры функций тяжело отличить от остальных в месте вызова. Это исправляется передачей по указателю или по значению с возвращением нового состояния изменяемого объекта.

 - Поддерживайте функции небольшими и компактными. Если функция достаточно велика, изменяемые параметры могут доставлять значительные неудобства. Есть различные способы снизить эти неудобства: разделить функцию на несколько, объединить несколько параметров в один прокси-объект или переписать функцию так, чтобы вместо совершения определённых действий над объектом она возвращала набор описаний этих действий. При этом важно понимать, что эти преобразования раздувают код и поэтому целесообразны только для достаточно больших проектов и функций, которые нельзя легко разбить на несколько. Простым небольшим функциям изменяемые параметры не вредят, но и злоупотреблять ими не стоит.

