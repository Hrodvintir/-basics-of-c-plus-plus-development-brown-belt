# std::variant и возврат его из функции
### Пример: функция с альтернативным исходом
Рассмотрим пример, похожий на рассмотренный в предыдущем материале про optional. Представьте себе функцию, которая возвращает некоторую величину — например, количество денег, которое необходимо списать за показ рекламного объявления. При этом по разным причинам эти деньги может не получиться списать, и тогда функция возвращает описание причины отказа в виде enum:
```c++
enum class FailReason {
  ZERO_BALANCE,
  LOW_BID,
  INVALID_CURRENCY,
  // ...
};

/* ??? */ ComputeCost(const Banner& banner) {
  if (banner.balance <= 0) {
    // -> FailReason::ZERO_BALANCE
  } else if (banner.bid < MIN_BID) {
    // -> FailReason::LOW_BID
  } else if (!IsCurrencyValid(banner.currency)) {
    // -> FailReason::INVALID_CURRENCY
  }
  // ...
  
  // -> ConvertBid(min(banner.bid, banner.balance), banner.currency)
}
```
Как вернуть из функции либо цену, либо причину отклонения? На ум приходят разные варианты, и все из них примерно так же плохи, как и pair вместо optional в рассказе про optional:

 - pair<uint64_t, FailReason> — пара, в которой заполнено либо first, либо second. Недостаток — неочевидность критерия успешности выполнения функции. Должна ли нулевая цена означать, что цена не вычислена и нужно обработать FailReason? Или нулевая цена вполне корректна для специальных бесплатных объявлений? Может быть, нужно ввести специальное «успешное» значение для FailReason? Нет уж, потом будем до скончания веков дописывать в функции вида void LogFailure(FailReason reason) странные проверки на reason == FailReason::OK.

 - tuple<bool, uint64_t, FailReason> — кортеж, в который мы от безысходности добавили bool, призванный помочь понять, какое из полей — uint64_t или FailReason — содержит истинный результат функции. Но сразу же возникает вопрос: как не ошибиться при трактовке значения bool? Когда там true, надо смотреть на цену или на FailReason?

Безусловно, проблемы с кортежем решаемы:

 - Заменить bool на enum с двумя значениями: COST_RESULT и FAIL_RESULT.

 - Заменить кортеж на структуру с понятными названиями полей: has_failed, cost, fail_reason.

Тем не менее, все эти варианты из-за своей громоздкости проигрывают простому решению: использовать класс, который гарантированно хранит объекты либо одного типа, либо другого.

### variant и возврат его из функции
Такой класс действительно есть в стандартной библиотеке языка, начиная с C++17, — это шаблон variant<T, U> из библиотеки <variant>: он гарантированно хранит либо объект типа T, либо объект типа U. (Этот же шаблон позволяет хранить и больше типов, но наиболее распространено применение с двумя типами.)

Перепишем функцию с его использованием:
  ```c++
  variant<uint64_t, FailReason> ComputeCost(const Banner& banner) {
  if (banner.balance <= 0) {
    return FailReason::ZERO_BALANCE;
  } else if (banner.bid < MIN_BID) {
    return FailReason::LOW_BID;
  } else if (!IsCurrencyValid(banner.currency)) {
    return FailReason::INVALID_CURRENCY;
  }
  // ...
  
  return ConvertBid(min(banner.bid, banner.balance), banner.currency);
}
  ```
  Отметим, что variant, подобно optional, может быть неявно сконструирован из объекта одного из нужных типов. Поэтому в функции достаточно писать return FailReason::LOW_BID;, не вызывая явно конструктор variant.

Разберём сразу типичный сценарий использования результата такой функции: залогировать причину неудачи, в противном случае неким образом ипользовать цену. Здесь помогут две функции:

 - holds_alternative<T>(v) — проверяет, правда ли объект v типа variant сейчас хранит в себе объект типа T.

 - get<T>(v) — возвращает ссылку на хранящийся в v объект типа T и бросает исключение в том случае, если v сейчас хранит объект другого типа.
  ```c++
  optional<uint64_t> cost;

if (const auto cost_or_failure = ComputeCost(banner);
    holds_alternative<FailReason>(cost_or_failure)) {
  LogFailure(banner, get<FailReason>(cost_or_failure));
} else {
  cost = get<uint64_t>(cost_or_failure);
}
  ```
  Обратите внимание, как в этом примере помогает optional: обернув в него целочисленную переменную, мы позволили иметь ей явное неинициализированное значение.  

### Особенности использования variant
Обратим внимание на несколько важных моментов в использовании variant.

Во-первых, variant<T, U> не может не хранить ни T, ни U. Если вам необходим «расширенный optional», то есть variant, который может хранить один из данных типов или ничего, используйте monostate. Он же помогает в случае необходимости хранить в variant типы, не имеющие конструктора по умолчанию.

Во-вторых, старайтесь не использовать variant с типами, которые могут неявно приводиться друг к другу. Как, например, будет работать такая функция?
  ```c++
  variant<int, double> GetSomeNumber() {
  return round(asin(0.5) * 180);
}
  ```
  Подвох в том, что round возвращает вещественное число и потому функция вернёт variant с double-альтернативой, хотя подразумевался наверняка int. variant, одновременно хранящий double, int и другие типы, может использоваться, например, для хранения вершины JSON.

Однозначно плохой пример — variant<uint32_t, size_t>: на 32-битных системах он и вовсе будет хранить два одинаковых типа, и get<size_t> в этом случае просто не скомпилируется.

### Итоги
Используйте шаблон variant в том случае, если вам необходимо вернуть из функции объект одного из множества типов. Следите за понятностью кода: для пользователя функции должно быть максимально прозрачно, что значит каждая из альтернатив.

